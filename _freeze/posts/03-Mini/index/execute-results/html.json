{
  "hash": "32a0d05b5f9d58c2a301b9b6e6ef9170",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Mini-Project-3\"\nformat: html\neditor: visual\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tibble)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=0.1\n\ngenerate_samp_prop <- function(n,p) {\n  \n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  lb <-phat -2.132*sqrt(phat* (1-phat)/n)\n  ub <-phat +2.132*sqrt(phat* (1-phat)/n)\n  \n  prop_df <-tibble(phat,lb,ub)\n  return(prop_df)\n}\ngenerate_samp_prop(n=5, p=0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   phat     lb    ub\n  <dbl>  <dbl> <dbl>\n1   0.2 -0.181 0.581\n```\n\n\n:::\n\n```{.r .cell-code}\nn_sim <-5000\n\nprop_ci_df <-map(1:n_sim, \\ (i) generate_samp_prop(n=5, p =0.1)) |> bind_rows()\n\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\n\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.329         0.402\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=0.1\ngenerate_samp_prop <- function(n,p) {\n  \n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  lb <-phat -2.132*sqrt(phat* (1-phat)/n)\n  ub <-phat +2.132*sqrt(phat* (1-phat)/n)\n  \n  prop_df <-tibble(phat,lb,ub)\n  return(prop_df)\n}\ngenerate_samp_prop(n=5, p=0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1     0     0     0\n```\n\n\n:::\n\n```{.r .cell-code}\nn_sim <-5000\n\nprop_ci_df <-map(1:n_sim, \\ (i) generate_samp_prop(n=5, p =0.1)) |> bind_rows()\n\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\n\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.333         0.409\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=0.55\ngenerate_samp_prop <- function(n,p) {\n  \n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  lb <-phat -2.132*sqrt(phat* (1-phat)/n)\n  ub <-phat +2.132*sqrt(phat* (1-phat)/n)\n  \n  prop_df <-tibble(phat,lb,ub)\n  return(prop_df)\n}\ngenerate_samp_prop(n=5, p=0.55)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1   0.8 0.419  1.18\n```\n\n\n:::\n\n```{.r .cell-code}\nn_sim <-5000\n\nprop_ci_df <-map(1:n_sim, \\ (i) generate_samp_prop(n=5, p =0.55)) |> bind_rows()\n\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\n\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.817         0.934\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=0.1\ngenerate_samp_prop <- function(n,p) {\n  \n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  lb <-phat -1.684*sqrt(phat* (1-phat)/n)\n  ub <-phat +1.6842*sqrt(phat* (1-phat)/n)\n  \n  prop_df <-tibble(phat,lb,ub)\n  return(prop_df)\n}\ngenerate_samp_prop(n=40, p=0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   phat       lb    ub\n  <dbl>    <dbl> <dbl>\n1  0.05 -0.00803 0.108\n```\n\n\n:::\n\n```{.r .cell-code}\nn_sim <-5000\n\nprop_ci_df <-map(1:n_sim, \\ (i) generate_samp_prop(n=40, p =0.1)) |> bind_rows()\n\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\n\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.152         0.902\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=0.55\ngenerate_samp_prop <- function(n,p) {\n  \n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  lb <-phat -1.684*sqrt(phat* (1-phat)/n)\n  ub <-phat +1.6842*sqrt(phat* (1-phat)/n)\n  \n  prop_df <-tibble(phat,lb,ub)\n  return(prop_df)\n}\ngenerate_samp_prop(n=40, p=0.55)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1 0.575 0.443 0.707\n```\n\n\n:::\n\n```{.r .cell-code}\nn_sim <-5000\n\nprop_ci_df <-map(1:n_sim, \\ (i) generate_samp_prop(n=40, p =0.55)) |> bind_rows()\n\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\n\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1     0.261         0.886\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=0.1\ngenerate_samp_prop <- function(n,p) {\n  \n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  lb <-phat -1.645*sqrt(phat* (1-phat)/n)\n  ub <-phat +1.645*sqrt(phat* (1-phat)/n)\n  \n  prop_df <-tibble(phat,lb,ub)\n  return(prop_df)\n}\ngenerate_samp_prop(n=300, p=0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n    phat     lb    ub\n   <dbl>  <dbl> <dbl>\n1 0.0967 0.0686 0.125\n```\n\n\n:::\n\n```{.r .cell-code}\nn_sim <-5000\n\nprop_ci_df <-map(1:n_sim, \\ (i) generate_samp_prop(n=300, p =0.1)) |> bind_rows()\n\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\n\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1    0.0567         0.888\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np=0.55\ngenerate_samp_prop <- function(n,p) {\n  \n  x <- rbinom(1, n, p) # randomly generate number of successes for the sample\n  \n  ## number of successes divided by sample size\n  phat <- x / n\n  lb <-phat -1.645*sqrt(phat* (1-phat)/n)\n  ub <-phat +1.645*sqrt(phat* (1-phat)/n)\n  \n  prop_df <-tibble(phat,lb,ub)\n  return(prop_df)\n}\ngenerate_samp_prop(n=300, p=0.55)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   phat    lb    ub\n  <dbl> <dbl> <dbl>\n1  0.57 0.523 0.617\n```\n\n\n:::\n\n```{.r .cell-code}\nn_sim <-5000\n\nprop_ci_df <-map(1:n_sim, \\ (i) generate_samp_prop(n=300, p =0.55)) |> bind_rows()\n\nprop_ci_df <- prop_ci_df |> mutate(ci_width = ub - lb,\n                                   ci_cover_ind = if_else(p > lb & p < ub,\n                                                          true = 1, \n                                                          false = 0))\n\nprop_ci_df |> summarise(avg_width = mean(ci_width),\n                        coverage_rate = mean(ci_cover_ind))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_width coverage_rate\n      <dbl>         <dbl>\n1    0.0943         0.892\n```\n\n\n:::\n:::\n\n\n\n\n```         \n|  |         | $n = $5 | $n = $40 | $n = $300 |\n|:----:|:-----------------:|:-------------:|:------------:|:------------:|\n| $p = 0.1$   | Coverage Rate       | 0.4   |  0.9072     |  0.8838         |\n| $p = 0.55$   | Coverage Rate       |0.93     |0.8846   | 0.897    |\n|    |                     |               |              |              |\n| $p = 0.1$    | Average Width        |0.332   |  0.152  |   0.057       |\n| $p = 0.55$    | Average Width        |0.817  |  0.262     |  0.094      |\n\n\n: Table of Results {.striped .hover}\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}